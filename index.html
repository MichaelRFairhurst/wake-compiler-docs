<!DOCTYPE html>
<html>
	<head>
		<title>Wake Programming Language</title>
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<!-- Bootstrap -->
		<link href="bootstrap/css/bootstrap.min.css" rel="stylesheet" media="screen">
		<link rel="stylesheet" href="/highlight.js/styles/tomorrow.css">
		<script src="/highlight.js/highlight.pack.js"></script>
		<script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
		<script type="text/javascript" src="page.js"></script>
		<link rel="stylesheet" type="text/css" href="page.css">
		<link href='http://fonts.googleapis.com/css?family=Roboto:100' rel='stylesheet' type='text/css'>
	</head>
	<body>
		<div class="mynavbar">
				<div class="btn-group" style="width: 100%">
					<a class="btn btn-block dropdown-toggle" data-toggle="dropdown" href="#">
						Try Wake Now
						<span class="caret"></span>
					</a>
					<ul class="dropdown-menu">
						<li><a href="TryWake.php">Try it Online</a></li>
						<li><a href="installing.html">Installation</a></li>
						<li><a href="howto.html">Quick Tutorial</a></li>
						<li><a href="https://github.com/MichaelRFairhurst/wake-compiler">View on Github</a></li>
					</ul>
				</div>
			<hr />
			<ul class="nav nav-tabs nav-stacked">
				<li><a href="howto.html">Quick Tutorial</a></li>
				<li><a href="installing.html">Installing</a></li>
				<li><a href="faq.html">FAQ</a></li>
				<li><a href="std.html">Standard Library</a></li>
				<li><a href="TryWake.php">Online Compiler</a></li>
				<li><a href="contributing.html">Wake Developer Guide</a></li>
				<li><a href="changelog.html">Changelog</a></li>
			</ul>
			<hr />
			<ul class="nav nav-tabs nav-stacked">
				<li><a href="#intro">Wake</a></li>
				<li><a href="#codeinto">Quick Code Introduction</a></li>
				<li><a href="#new">New ideas in Wake</a></li>
				<li><a href="#removals">What we removed</a></li>
				<li><a href="#trywake">Try Wake online</a></li>
				<li><a href="#variables">Variables</a></li>
				<li><a href="#typevariables">- Types as Variables</a></li>
				<li><a href="#aliases">- Aliased Variables</a></li>
				<li><a href="#shadowing">- Shadowing Types</a></li>
				<li><a href="#declarations">- Declaring Variables</a></li>
				<li><a href="#optionals">- Optional Types</a></li>
				<li><a href="#optionalmethods">- Optional Members and Methods</a></li>
				<li><a href="#lists">- Using Lists</a></li>
				<li><a href="#iterating">- Iterating over Lists</a></li>
				<li><a href="#typesafelists">- Typesafe List Access</a></li>
				<li><a href="#operators">Operators</a></li>
				<li><a href="#modulo">- Notes on Modulo</a></li>
				<li><a href="#classes">Classes</a></li>
				<li><a href="#dependencies">- Dependencies</a></li>
				<li><a href="#properties">- Properties</a></li>
				<li><a href="#inheritance">- Inheritance</a></li>
				<li><a href="#methods">Methods</a></li>
				<li><a href="#invoking">- Invoking Methods</a></li>
				<li><a href="#overloading">- Overloading Methods</a></li>
				<li><a href="#generics">Generics</a></li>
				<li><a href="#genericmethods">- Generics Methods</a></li>
				<li><a href="#provisions">Provisions</a></li>
				<li><a href="#plainprovisions">- Plain Provisions</a></li>
				<li><a href="#specializedprovisions">- Specialized Provisions</a></li>
				<li><a href="#primitiveprovisions">- Providing Primitive Values</a></li>
				<li><a href="#ctorprovisions">- Constructor Provisions</a></li>
				<li><a href="#provisionargs">- Provisions Arguments</a></li>
				<li><a href="#behavioralprovisions">- Behavioral Provisions</a></li>
				<li><a href="#closures">Closures</a></li>
				<li><a href="#astypes">- As Types</a></li>
				<li><a href="#typeinference">- Type Inference</a></li>
				<li><a href="#selfexecuting">- Self Executing</a></li>
				<li><a href="#thiscontext">- Keeping This Context</a></li>
				<li><a href="#enclosing">- Enclosing Local Vars</a></li>
				<li><a href="#ternaries">Ternary Operators</a></li>
				<li><a href="#annotations">Annotations</a></li>
				<li><a href="#unittests">Unit tests</a></li>
				<li><a href="#mocks">Mocks</a></li>
				<li><a href="#entry">Program entry points</a></li>
			</ul>
		</div>
		<div class="opennav"><button class="btn btn-inverse btn-small"><i class="icon-align-justify icon-white"></i></button></div>
		<div class="content" data-spy="scroll" data-target=".mynavbar">
			<div class="inner-content">

			<div id="intro">
				<div id="logo">
				</div>
				<h2><a class="logo-label" href="/">WAKE</a></h2>
				<p class="logo-label-label">
				a <span class="accent">fast</span>, <span class="accent">expressive</span>, <span class="accent">typesafe</span> language that gives you <span class="accent">testability from the ground up</span>.
				</p>
			</div>
			<h1>A Modern Programming Language</h1>
			<p>Wake is a brand new programming language aimed at solving modern problems, such as code testability, expressive typesafety, and language interoperability.</p>
			<p>Throughout the docs, we'll show you how we've made the language <span class="label label-inverse">testable</span>, <span class="label label-inverse">flexible</span>, <span class="label label-inverse">readable</span>, <span class="label label-inverse">concise</span>, and <span class="label label-inverse">safe</span>.</p>
			<hr />
			<h1 id="codeinto">Quick Code Introduction</h1>
			<p>We'll compare Wake to both java and javascript. You'll see friendly classes, clean code, and intuitive type safety.</p>
			<p>or you can <b>jump straight in:</b></p>
			<ul>
				<li><a href="#variables">How variables work</a></li>
				<li><a href="#methods">Valid method names &amp; APIs</a></li>
				<li><a href="#classes">Using classes</a></li>
				<li><a href="#provisions">Tell me about provisions</a></li>
				<li><a href="#closures">Take a look at our closures</a></li>
				<li><a href="#entry">Where does the program begin?</a></li>
				<li><a href="#unittests">How do I write tests?</a></li>
			</ul>
			<div class="row">
				<div class="span6">
					<h3>Wake</h3>
					<div class="alert alert-success" immovable>Code as concise as javascript, with inheritance and typesafety and more</div>
					<span class="label label-info">Wake (510 bytes)</span>
					<pre><code class="wake"
>every RecordValidator is:

    needs SessionHolder,

    Bool -- validate(Record[]) {
        return Record[].any({
            r -&gt; return !validate(r);
        });
    }

    Bool -- validate(Record) {
        var Account[]?
                = Record.lastRevision.?User.?getAccounts();

        if Account[] exists {
            return Account[].any({
                a -&gt; return SessionHolder.hasAccount(a);
            });
        }

        return Record.Revisions[].filter({
            r -&gt; return usesLimits(r);
        }).length &lt; 3;
    }

    Bool -- usesLimits(Revision) {
        return SessionHolder.hasUser(Revision.User);
    }</code></pre>
				</div>
				<div class="span6" id="javascript">
					<h3>Javascript / <a onclick="$('#java').show();$('#javascript').hide();">Java</a></h3>
					<div class="alert alert-error" immovable>Elegant and concise, but unintiuitive, unsafe, with pitfalls all around</div>
					<span class="label label-important">Javascript (739 bytes)</span>
					<pre><code class="javascript"
>var RecordValidator = function(sessionHolder) {

    this.validateRecords = function(records) {
        for(var i = 0; i &lt; records.length; i++) {
            if(!validate(records[i])) {
                return false;
            }
        }
        return true;
    }

    this.validateRecord = function(record) {
        if(record.lastRevision !== undefined
            && record.lastRevision.user != undefined
        ) {
            var accounts
                = record.lastRevision.user.getAccounts();
            for(var i = 0; i &lt; accounts.length; i++) {
                if(!sessionHolder.hasAccount(accounts[i])) {
                    return false;
                }
            }
            return true;
        }

        var that = this;
        return record.revisions.map(function(r) {
            return that.usesLimits(r);
        });
    }

    this.usesLimits = function(revision) {
        return sessionHolder.hasUser(revision.user);
    }

}</code></pre>
				</div>
				<div class="span6" style="display:none" id="java">
					<h3><a onclick="$('#java').hide();$('#javascript').show();">Javascript</a> / Java</h3>
					<div class="alert alert-error" immovable>Powerful and typesafe at the expense of clunky boilerplate</div>
					<span class="label label-important">Java (910 bytes)</span>
					<pre><code class="java"
>public class RecordValidator {

    public RecordValidator(SessionHolder mySessionHolder) {
        sessionHolder = mySessionHolder;
    }

    protected SessionHolder sessionHolder;

    public boolean validate(List&lt;Record&gt; records) {
        for(Record record : records) {
            if(!validate(records[i])) {
                return false;
            }
        }
        return true;
    }

    public boolean validate(Record record) {
        if(record.lastRevision != null
            && record.lastRevision.user != null
        ) {
            List&lt;Account&gt; accounts
                = record.lastRevision.user.getAccounts();
            for(Account account : accounts) {
                if(!sessionHolder.hasAccount(account)) {
                    return false;
                }
                return true;
            }

        }

        int num = 0;
        for(Revision revision : record.revisions) {
            if(usesLimits(revision)) {
                num++;
                if(num &gt; 3) {
                    return false;
                }
            }
        }
    }

    public boolean usesLimits(Revision revision) {
        return sessionHolder.hasUser(revision.user);
    }

}</code></pre>
				</div>
			</div>
			<hr />
			<h1 id="new">New ideas in Wake</h1>
			<p>We've both created and borrowed some cutting edge ideas.</p>

			<div class="row">
				<div class="span3">
					<h4>Provisions</h4><span class="label label-inverse">testable</span> <span class="label label-inverse">flexible</span>
				</div>
				<div class="span5">
					<br /><blockquote>Use provisions to keep a testable and extensible seam between every class.</blockquote>
				</div>
				<div class="span4">
					<br /><div class="alert alert-success" immovable>This makes testability and flexibility a language feature.</div>
				</div>
			</div>

			<div class="row">
				<div class="span3">
					<h4>Type Inference</h4><span class="label label-inverse">concise</span>
				</div>
				<div class="span5">
					<br /><blockquote>Keep the expressive, clean look of dynamic languages, with a safe type system.</blockquote>
				</div>
				<div class="span4">
					<br /><div class="alert alert-success" immovable>This saves you time writing, reading, and refactoring code.</div>
				</div>
			</div>

			<div class="row">
				<div class="span3">
					<h4>Constructor Properties</h4><span class="label label-inverse">testable</span> <span class="label label-inverse">concise</span>
				</div>
				<div class="span5">
					<br /><blockquote>Reduce boiler-plate code by making constructor arguments exactly like properties.</blockquote>
				</div>
				<div class="span4">
					<br /><div class="alert alert-success" immovable>This makes best practices like Aspect-Oriented-Programming intuitive.</div>
				</div>
			</div>

			<div class="row">
				<div class="span3">
					<h4>Two-way polymorphism</h4><span class="label label-inverse">testable</span> <span class="label label-inverse">flexible</span>
				</div>
				<div class="span5">
					<br /><blockquote>Eventually will add this.</blockquote>
				</div>
				<div class="span4">
					<br /><div class="alert alert-success" immovable>This creates testable inheritance by increasing expressive object design.</div>
				</div>
			</div>

			<div class="row">
				<div class="span3">
					<h4>Compilation targets as a language feature</h4><span class="label label-inverse">flexible</span>
				</div>
				<div class="span5">
					<br /><blockquote>A goal of Wake is to compile into anything -- .net, java, javascript, and assembly</blockquote>
				</div>
				<div class="span4">
					<br /><div class="alert alert-success" immovable>This makes Wake libraries usable in every one of your projects.</div>
				</div>
			</div>

			<div class="row">
				<div class="span3">
					<h4>Closures</h4><span class="label label-inverse">flexible</span> <span class="label label-inverse">concise</span>
				</div>
				<div class="span5">
					<br /><blockquote>Wake is part of a small class of strongly-typed, object oriented languages with <a href="#closures">functional coloring.</a></blockquote>
				</div>
				<div class="span4">
					<br /><div class="alert alert-success" immovable>This adds concise, elegant, rapid-development to your scalable enterprise apps.</div>
				</div>
			</div>

			<hr />

			<h1 id="removals">What Wake did without</h1>
			<p>Any poor feature in a language can prevent the addition of a powerful one. We made some hard choices to create a strong cocktail of ideas.</p>
			<table class="table">
				<tr>
					<th>What we cut</th>
					<th>Why we cut it</th>
					<th>What it enabled</th>
				</tr>
				<tr>
					<td><b>Static methods</b></td>
					<td><div class="alert alert-error" immovable>Using a static method from a procedure hard-codes implementation rather than interface, decreasing flexibility and testability</div></td>
					<td><span class="label label-success">FIXED</span> You can (and usually should) now use exact type names as variable names, meaning more clarity and fewer keystrokes.</td>
				</tr>
				<tr>
					<td><b>The <code>new</code> keyword</b></td>
					<td><div class="alert alert-error" immovable><code>new</code> mixes application APIs with implementations, and has been replaced with 'provisions.'</div></td>
					<td><span class="label label-success">FIXED</span> Constructors directly translate to properties since they are not functions.</td>
				</tr>
				<tr>
					<td><b>Interface/extension distinction</b></td>
					<td><div class="alert alert-error" immovable>A common best practice is to create an interface for every class, even before its used, resulting in junk code and extra boilerplate.</div></td>
					<td><span class="label label-success">FIXED</span> In Wake you can use any class as an interface, making everything driven by APIs without any additional code.</td>
				</tr>
				<tr>
					<td><b>Abstract classes</b></td>
					<td><div class="alert alert-error" immovable>Abstract classes are a combination of an interface and a class, or a means of locking a class to static methods.</div></td>
					<td><span class="label label-success">FIXED</span> We let the compiler tell you if a class is incomplete, not vice versa, without any management on your part.</td>
				</tr>
				<tr>
					<td><b>Primitive types</b></td>
					<td><div class="alert alert-error" immovable>Primitive types are fast, but without methods they require external behavior to manipulate them.</div></td>
					<td><span class="label label-success">FIXED</span> The compiler handles autoboxing primitives into objects - <code>Num</code>, <code>Bool</code>, <code>Text</code>, etc - and lets you code without managing the conversion.</td>
				</tr>
				<tr>
					<td><b>Cryptic keywords</b></td>
					<td><div class="alert alert-error" immovable><code>Abstract</code>, <code>virtual</code>, <code>volatile</code>, and other cryptic keywords from the 1970s convey very little about what they actually do.</div></td>
					<td><span class="label label-success">FIXED</span> New programmers will find every keyword to be simple, and meaningful, from <code>Text</code> to <code>capable</code> to <code>needs</code>.</td>
				</tr>
			</table>

			<div class="hero-unit" id="trywake">
				<h1 id="trywake">Try Wake Online</h1>
				<p>We handled installing it for you, and with javascript as a compile target, you can run it all right in your browser</p>
				<h3><a href="TryWake.php">Try Wake Online</a></h3>
			</div>

			<hr />

			<h1 id="variables">Making The Most Of Wake Variables</h1>
			<div class="alert alert-success">Variables in Wake come in three forms, all with the goal of meaningful names in minimal keystrokes.</div>
			<h3 id="typevariables">1. Typenames as variables <span class="label label-inverse">concise</span> <span class="label label-inverse">readable</span></h3>
			<p>Since we got rid of static methods, we can save you from repeating yourself meaninglessly in domain-driven code.</p>
			<div class="row">
				<div class="span6">
					<span class="label label-info">Wake</span>
					<pre><code class="wake"
>every Person is:

    needs <span class="goodcode" title="You can tell the compiler its a Num called ID, or, when you want, simply call it a Num.">Num</span>;

    Num -- getId() {
        return <span class="goodcode" title="Here we use our Num ID, that we simply chose to call 'Num.'">Num</span>;
    }

    Bool -- isSameAs(<span class="goodcode" title="Save yourself writing 'Person' twice, and you get the benefit of knowing that Person is a Person.">Person</span>) {
        return getId() == <span class="goodcode" title="Clear, concise, and the programmer knows the type as well as the compiler.">Person</span>.getId();
    }</code></pre>
				</div>
				<div class="span6">
					<span class="label label-important">Java</span>
					<pre><code class="java"
>class Person {

    private <span class="badcode" title="Here we must say its an int, and even though that is often enough to make it unique, we must also name it.">int id</span>;

    public Person(int <span class="badcode" title="Here we have made a useless name to explain that this is not the same Num as the property. The programmer juggles what this means and determines it is a useless distinction.">myid</span>) {
        id = myid;
    }

    public int getId() {
        return id;
    }

    public bool isSameAs(<span class="badcode" title="Here we write this out twice for no good reason, or we name it something else when we only truly care that this variable is a Person.">Person person</span>) {
        return getId() == <span class="badcode" title="This looks almost exactly like a static method call, meaning descriptive variable names can actually create confusion.">person</span>.getId();
    }
}</code></pre>
				</div>
			</div>
			<h3 id="aliases">2. Aliasing <span class="label label-inverse">readable</span> <span class="label label-inverse">safe</span></h3>
			<p>In our previous example, calling a person's ID <code>Num</code> is a bit ambiguous. When a type isn't meaningful for a context, use aliases.</p>
			<p>To aid the compiler, we must write aliases in lowercase, to hint that its not a type. But luckily, it turns out that the same idea is useful to humans as well. It also allows us to write aliases before or after our type to make our code more literate.</p>
			<div class="row">
				<div class="span6">
					<span class="label label-info">Wake</span>
					<pre><code class="wake"
>every Person is:

    needs Num <span class="goodcode" title="Here we give our Num a name.">id</span>;

    Num -- getId() {
        return <span class="goodcode" title="Here we use our Num by its alias, id. We know that it is not a typename.">id</span>
    }

    setIdThenSave(<span class="goodcode" title="You can precede variables with aliases.">newid Num</span>, <span class="goodcode" title="You can also precede variables by their type.">Bool recursively</span>) {
        ...
    }</code></pre>
				</div>
				<div class="span6">
					<span class="label label-important">Java</span>
					<pre><code class="java"
>class Person {

    private int id;

    public Person(int myid) {
        id = myid;
    }

    public int getId() {
        return id;
    }

    public void setIdThenSave(<span class="badcode" title="Sometimes functions read better with types first or second, but you have no choice.">int id</span>, bool recursively) {
        //...
    }
}</code></pre>
				</div>
			</div>
			<h3 id="shadowing">3. Shadowing <span class="label label-inverse">concise</span> <span class="label label-inverse">safe</span></h3>
			<p>Following from the idea that the most meaningful name for a variable often <i>is</i> its type, we have a problem with places like 'setter' methods. The new value is of the same type as the old value, but they must be distinguished.</p>
			<p>Instead of creating meaningless aliases as we arguably did with <code>newid</code>, we can add <code>$</code> to preserve type information while also creating a unique instance</p>
			<span class="label label-info">Wake</span>
			<pre><code class="wake"
>every NumContainer is:

    needs Num;

    Num -- setToNotGreaterThan(<span class="goodcode" title="Here, all we really care about is that Num and $Num are different variables; we don't force you to come up with a unique name.">$Num</span>) {
        if(Num &gt; <span class="goodcode" title="While this can be confusing, this is a usage of $Num the argument rather than Num the property. We let you decide when its appropriate, such as short statements and algorithms.">$Num</span>) Num = $Num;
    }</code></pre>
			<h3 id="declarations">Declaring variables <span class="label label-inverse">concise</span> <span class="label label-inverse">safe</span></h3>
			<p>All these variable names are usable in declarations when preceded with <code>:</code>, or when in properties</p>
			<span class="label label-info">Wake</span>
			<pre><code class="wake"
>every DeclarationExample is:

    <span class="goodcode" title="Here we define an object property.">with Num here = 4;</span>
    with some Num = 4;
    with $Num = 4;
    <span class="goodcode" title="Properties can be public.">with public Num too = 5;</span>

    <span class="goodcode" title="Here we define dependencies.">needs another Num, $$Num, Num again;</span>

    declareThem() {
        <span class="goodcode" title="Here we define variables within a method.">var local Num = 4;</span>
        var second Num = 4;
        var $$$Num = 5;
        <span class="badcode" title="Compiler error! In Wake you cannot redefine variables.">var Num = 3</span>;
    }</code></pre>

			<h3 id="optionals">Optional Types <span class="label label-inverse">typesafe</span></h3>
			<p>Wake will guarantee the existence of most variables, arguments, and return types. This prevents rogue NullPointerExceptions, or segfaults, or fatal errors that large apps in other languages frequently succumb to.</p>
			<p>The flip side to this is that when a value may not exist, it must be declared <i>optional</i> with <code>?</code>. Before using an optional type, the compiler ensures you have accounted for the possibility of it not existing with <code>exists</code> clauses.</p>
			<span class="label label-info">Wake</span>
			<pre><code class="wake"
>every OptionalTypeUsage is:

    Num? -- mayReturnAnNumAndAcceptsA(Num?) {
        <span class="goodcode" title="You can always assign a real type to an optional one.">Num = 5;</span>
        <span class="goodcode" title="You can always set an optional type to Nothing.">Num = Nothing;</span>
        <span class="goodcode" title="This checks if Num is not Nothing. Inside this block, Num is no longer an optional type.">if Num exists {</span>
            return Num + 7;
        } else {
            return Nothing;
        }
    }
</code></pre>

			<h3 id="optionalmethods">Optional Members and Methods <span class="label label-inverse">typesafe</span></h3>
			<p>To easily look into a data structure with optional types, you can use the <code>.?</code> operator to get members and call methods when the subject exists.</p>
			<div class="alert alert-info">Remember, optionals can be nested as in <code>Num??</code>. You can use <code>.?</code> on a nested optional, and it will unwrap as far as it needs. Remember than nested optionals carry more meaning than a plain optional, and be wary of discounting the <i>reason</i> it was nested before you accessed it with <code>.?</code>.</div>
			<span class="label label-info">Wake</span>
			<pre><code class="wake"
>every OptionalTypeUsage is:

    Text? -- getNameOf(Person?) {
        <span class="goodcode" title="This returns a name when the person exists. Therefore, instead of returning a Text it returns a Text?.">return Person.?name;</span>
        <span class="goodcode" title="Just like working on the member 'name', you can do the same with methods like 'getName()'. Be wary of side-effects here!">return Person.?getName();</span>
    }
</code></pre>
			<h3 id="lists">Using Lists <span class="label label-inverse">typesafe</span></h3>
			<div class="alert alert-warning">
				For ease of use, the type returned by T[x] is a T, and not a T?. For this reason, getting an unassigned list index will throw an exception so that the type system is happy. Safe accesses return T? and do not throw, and are covered after this.
			</div>
			<p>Lists (called Arrays in many other languages) are a way of storing sets of a particular type. They are incredibly useful.</p>
			<span class="label label-info">Wake</span>
			<pre><code class="wake"
>every ListUsage is:

    methodWithListArgument(<span class="goodcode" title="Here we accept a list of Nums">Num[]</span>) {
        <span class="goodcode" title="Set the first Num in the list.">Num[0] = 5;</span>
        <span class="goodcode" title="Declare an empty list of Nums again.">var $Num[] = [];</span>
        <span class="goodcode" title="Declare a list of Nums again, except with three starting values.">var $$Num[] = [1, 2, 3];</span>
        <span class="goodcode" title="Declare a list lists of Nums, containing our lists of Nums.">var combined Num[][] = [Num[], $Num[], $$Num[]];</span>
    }</code></pre>
			<div class="alert alert-warning">You will get an error if you try to declare <code>Num[]</code> in the same scope as <code>Num[][]</code>, and for good reason.</div>
			<p>Unless lists of lists in Wake to look like <code>Num[][0]</code> or <code>Num[0][]</code>, we must face an ambiguity problem when <code>Num[]</code> and <code>Num[][]</code> share a scope. Since <code>Num[0]</code> is the correct syntax for both of these variables, the compiler forces you to rename one or the other. This is not the case for <code>Num[]</code> and <code>Num</code>.</p>
			<hr />

			<h3 id="iterating">Iterating over Lists <span class="label label-inverse">concise</span> <span class="label label-inverse">readable</span></h3>
			<p>Since Wake blurs the line between variables and types, we can boast the smallest foreach loop of any language.</p>
			<span class="label label-info">Wake</span>
			<pre><code class="wake"
>every PersonDatabase is:

    delete(Person[]) {
        foreach(<span class="goodcode" title="The compiler reduces Person[] to Person, and performs the following code for each person in our list.">Person[]</span>) Person.delete();
    }</code></pre>
			<div class="alert alert-success">This works as you would expect for shadowed variables, where <code>$Person[]</code> becomes <code>$Person</code>. And it also works for expressions, where <code>foreach(db.getPeople())</code> lets you iterate over <code>Person</code>, since the compiler knows your db returns <code>Person[]</code>.</div>
			<p>Wake also supports giving custom names to the items you iterate over, and will <b>soon</b> support getting the index at the same time.</p>
			<span class="label label-info">Wake</span>
			<pre><code class="wake"
>every PersonDatabase is:

    delete(Person[]) {
        foreach(<span class="goodcode" title="Explicitly name the variable you're iterating over.">$Person</span> in Person[]) $Person.delete();
        foreach(person in Person[]) person.delete();
        foreach(Person[] <span class="goodcode" title="Sometimes its important to know the index of which Person you're iterating over.">at Num</span>) <span class="goodcode" title="Make each person greet themselves - Person and Person[Num] are equivalent.">Person.greet(Person[Num]);</span>
        foreach(person in Person[] at Num) person.greet(Person[Num]);
    }</code></pre>

			<h3 id="typesafelists">Typesafe Lists <span class="label label-inverse">readable</span> <span class="label label-inverse">typesafe</span></h3>
			<p>Of course, all lists in Wake are already typesafe. However, when writing in Wake you can choose to get an item out of an array as an optional, avoiding the often-convenient-but-sometimes-nasty <code>UndefinedIndexException</code>. The flipside of this is that you then must check that the item exists before you can use it.</p>
			<div class="alert alert-info">This pairs especially well with the <code>.?</code> operator, allowing you to say, pass a notification easily with <code>Listener[?0].?fire(Message)</code>; safely operating only when the <code>Listener</code> exists.</div>
			<br />
			<pre><code class="wake"
>every ListUsage is:

    method(Num[]) {
        var <span class="goodcode" title="We declare this as an optional num, which is more accurate. This is a good example of where we don't know the 1st Num exists, and the compiler helps us out.">Num?</span> = <span class="goodcode" title="This returns a Num? instead of throwing an UndefinedIndexException">Num[?0]</span>;
        <span class="goodcode" title="The compiler makes sure we treat the Num as an optional, preventing bugs.">if Num exists {</span>
            ...
        }
    }</code></pre>

			<h1 id="operators">Operators in Wake <span class="label label-inverse">concise</span> <span class="label label-inverse">typesafe</span></h1>
			<p>Operator precedence has been copied from Java. The new ones here are links to their usage descriptions.</p>
			<p>Supported operators (in no particular order): <code>+</code>, <code>-</code>, <code>=</code>, <code>|</code>, <code>||</code>, <code>&amp;&amp;</code>, <code>/</code>, <code>*</code>, <a href="#optionalmethods"><code>.?</code></a>, <code>[ ]</code>, <code>^</code>, <a href="#typesafelists"><code>[? ]</code></a>, <code>.</code>, <code>!</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;</code>, <code>&lt;</code>, <code>:=</code>, <code>+=</code>, <code>-=</code>, <code>/=</code>, <code>*=</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>!=</code>, <code>==</code>, <code>~</code>, <a href="#modulo"><code>%</code>, <code>%%</code>, <code>%%%</code></a>.</p>
			<p>Why does Wake support both <code>=</code> and <code>:=</code>? Both do the same thing, but <code>=</code> does not return a value. That means you cannot use <code>=</code> in the condition of an if-statement or a subexpression. To ensure you really intended <code>=</code> and not <code>==</code>, you must opt-in by using <code>:=</code>, which does return a value. This also stands out visually for others who later read your code.</p>
			<p>Note that <code>^</code> is bitwise XOR and not an exponent.</p>
			<h3 id="modulo">Notes on Modulo</h3>
			<p>Modulo is an interesting operator to support in terms of language interoperability. Programming languages are split into two camps when performing modulo on negative numbers. It is often considered more mathematically accurate to keep the sign of the divisor, however it can be faster to keep the sign of the dividend. However, if using the sign of the divisor is the "native" modulo, often using the sign of the divisor is actually slower.</p>
			<p>In Wake we wanted the modulo operator to work the same everywhere, while still allowing for fast code. The solution we came up with is to have the three modulos, <code>%</code>, <code>%%</code>, and <code>%%%</code>. By default, we determined behavior needed to be standard across all language targets, making the more accurate approach ideal. Therefore the behavior of <code>%</code> is to keep the sign of the divisor. You are unlikely to ever have to worry about modulo beyond these great defaults.</p>
			<p>If you are not dealing with negative numbers in your modulo, we give you the opt-in potential to use <code>%%</code>. Since modulo is often used for tight, performant code, we made this operator to guarantee speed over consistency.</p>
			<p>Lastly, the <code>%%%</code> operator is there to complete the picture, using the sign of the dividend. Perhaps you have code that relies on the negative behavior of <code>%%</code> on a dividend-native language, and want to use it on a divisor-native language. Or perhaps you wish consistency and only care about performance on a dividend-native language. Its available for the sake of completeness and control.</p>
			<h1 id="classes">Classes in Wake <span class="label label-inverse">concise</span> <span class="label label-inverse">readable</span></h1>
			<p>Wake is a truly Object Oriented language, and should come with few surprises here.</p>
			<p>In Wake, everything is an object. A class declaration begins with the keyword <code>every</code> as seen below. Within that definition can be properties, dependencies, a constructor, methods, and provisions.</p>
			<span class="label label-info">Wake</span>
			<pre><code class="wake"
>every MyClass is:
    <span class="goodcode" title="Here we have an object property.">with public Text name;</span>
    <span class="goodcode" title="Properties default to private.">with Text ssn;</span>

    needs <span class="goodcode" title="Here we have dependencies. The object cannot exist without them.">Num id, Printer</span> then {
        <span class="goodcode" title="You can declare 'needs nothing then {...} to have a constructor with no dependencies.">// constructor body</span>
    }

    <span class="goodcode" title="Provisions; the details are in their own section.">provides Text:URL &lt;- 'http://www.wakelang.com';</span>

    <span class="goodcode" title="A method declaration.">Text -- getSSNLastFour() {</span>
        // ...
    }</code></pre>
			<h3 id="dependencies">Dependencies <span class="label label-inverse">concise</span> <span class="label label-inverse">testable</span></h3>
			<p>When an object is constructed, first the dependencies are all resolved by means of provisions. This means that you can simply say your object <code>needs Printer</code>, and you will always have one.</p>
			<span class="label label-info">Wake</span>
			<pre><code class="wake"
>every FileStream is:
    needs Text filename, <span class="goodcode" title="needs can be public properties, too.">public OutStream;</span></code></pre>
			<h3 id="properties">Properties <span class="label label-inverse">flexible</span></h3>
			<p>At this point the object has its dependencies met, and each property can use the needs in their initialization. Then the constructor is called.</p>
			<span class="label label-info">Wake</span>
			<pre><code class="wake"
>every IncrementingProperties is:
    needs Num starter, Printer {
        Printer.print(<span class="goodcode" title="By now, the property sum exists.">sum</span>);
    }

    with Num <span class="goodcode" title="When plusone is declared, starter already exists since its a dependency.">plusone = starter + 1;</span>
    with Num <span class="goodcode" title="Since plustwo is declared after plusone, we can use it to evaluate its initial value.">plustwo = starter + 2;</span></code></pre>
			<h3 id="inheritance">Inheritance <span class="label label-inverse">testable</span> <span class="label label-inverse">flexible</span> <span class="label label-inverse">readable</span></h3>
			<p>Every class can be inherited with or without keeping behavior, with the keywords <code>a</code>/<code>an</code>, and <code>capable</code>. Usually in small projects the point of inheritance is to copy the code from that class, however, it is not always desirable. If you use <code>capable</code>, you must rewrite the methods of your child class. These actions are called <i>extending</i> vs <i>implementing</i>.</p>
			<p>An additional value to implementing classes with <code>capable</code> instead of extending classes with <code>a</code>/<code>an</code>, is that you can implement multiple classes even though you can only extend one class.</p>
			<p>An object which extends or implements another class can be used as that subclass elsewhere in the code.</p>
			<span class="label label-info">Wake</span>
			<pre><code class="wake"
>every BaseClass is:

    myMethod(Printer) {
        Printer.print("BaseClass");
    }

every SubClass (<span class="goodcode" title="Subclass extends BaseClass, meaning SubClass can use myMethod off of BaseClass.">a BaseClass</span>, <span class="goodcode" title="We implement Printer, meaning we must declare the method print().">capable Printer</span>) is:

    needs Printer;

    <span class="goodcode" title="Here we define Printer.print() so we can be a capable printer.">print(Text)</span> {
       Printer.print("SubClass printing: " + Text);
    }

    <span class="goodcode" title="Running this method will output &quot;SubClass printing: BaseClass&quot;">useThisAsPrinter</span>() {
        <span class="goodcode" title="Use BaseClass.myMethod since SubClass is a BaseClass. You can also do this with parent.myMethod()">myMethod</span>(<span class="goodcode" title="We can send 'this' as the argument of myMethod(Printer) since SubClass is a capable Printer.">this</span>);
    }</code></pre>
			<hr />
			<h1 id="methods">Valid Methods in Wake <span class="label label-inverse">concise</span> <span class="label label-inverse">readable</span></h1>
			<div class="alert alert-info">
				Methods in Wake can look strange at first. The changes are simple and make your APIs read like sentences.
			</div>
			<p>In java, a detailed method signature may look like:</p>
			<code style="display: block">addExaminerToContractWithMedicalCompany(Examiner examiner, MedicalCompany company)</code>
			<p>We decided we can do better. In Wake you could rewrite that method as:</p>
			<code style="display: block">add(Examiner)ToContractWith(MedicalCompany)</code>
			<p>Here are some examples:</p>
			<span class="label label-info">Wake</span>
			<pre><code class="wake"
>every MethodExample is:
    ReturnType -- methodWithReturn() {}
    methodWithNoReturnValue() {}
    abstractMethodWithNoImplementation();
    methodWithArgument(Num) {}
    methodWithArgument(this Num) {}
    methodWithArgument(Num here) {}
    methodWith(Num)ArgumentAnd(Text)Argument() {}</code></pre>
			<h3 id="invoking">Invoking Methods <span class="label label-inverse">readable</span></h3>
			<p>Invoking methods (that is, calling a method's code on a particular object and argument set) looks almost exactly like defining one.</p>
			<span class="label label-info">Wake</span>
			<pre><code class="wake"
>every MethodInvoker is:

    methodWithArgument(Bool) {
        <span class="goodcode" title="Now that we've defined methodWithArgument(Bool), we invoke it inside a Wake statement.">methodWithArgument(!Bool);</span>
    }</code></pre>
		<h3 id="overloading">Method Overloading <span class="label label-inverse">readable</span> <span class="label label-inverse">concise</span></h3>
		<div class="alert alert-warning">Method overloading can create more confusion than it prevents. As a general rule, avoid using overloading and aliases together for the clearest code.</div>
		<p>Method overloading exists in C++ and java. A method can accept differently typed objects, and have different behaviors for each. Used properly, it creates shorter method names that focus on behavior rather than implementation.</p>
			<span class="label label-info">Wake</span>
		<pre><code class="wake"
>every CrossTypeComparator is:
    Bool -- compare( Text )And( $Text ) {
        <span class="goodcode" title="Here we can write code that returns if a Text comes alphabetically before another.">//...</span>
    }

    Bool -- compare( Num )And( $Num ) {
        <span class="goodcode" title="Here we can write code that returns if a Num is less than the other.">return Num &lt; $Num;</span>
    }</code></pre>
		<hr />
		<h3 id="generics">Generics <span class="label label-inverse">flexible</span> <span class="label label-inverse">typesafe</span></h3>
		<p>Like Java, C#, and other languages, Wake supports generic types.</p>
		<div class="alert alert-info">Generics are required for a powerful static type system. Unlike Wake, Java and C# did not have generics in early versions. As such, the type safety and performance of arrays in these languages was thrown out to accomodate missing flexibility. Wake had generics from version one and does not suffer these drawbacks.</div>
		<div class="alert alert-info">The Wake syntax uses curly braces instead of angle brackets for generics. This simple difference speeds up compilation and makes parsing easier for independent programs, as it is a 100% context-free grammar.</div>
		<div class="alert alert-error">These examples use function types that are not yet implemented.</div>
			<span class="label label-info">Wake</span>
		<pre><code class="wake"
>every CalculationCache<span class="goodcode" title="A calculation cache holds a value of any type T.">{T}</span> is:
    with <span class="goodcode" title="This may hold an integer, text, a class, or even yet another calculation cache. Calling code decides.">T?</span> = <span class="goodcode" title="Begin the cache as empty">nothing</span>;
    needs <span class="goodcode" title="Store the function to calculate the value">T -- fn()</span> calculation;
    <span class="goodcode" title="Here we provide the calculated value of type T.">T</span> -- getValue() {
        if(<span class="goodcode" title="Use our type T by its typename since it was not aliased.">T</span> == nothing) {
            T = calculation();
        }
        return T;
    }</code></pre>
	<p>The type information of a generic is deffered until the moment where its used. For those unfamiliar with generics, using one would look like this.</p>
			<span class="label label-info">Wake</span>
		<pre><code class="wake"
>every Squarer is:
    needs Num;
    provides <span class="goodcode" title="Specific variations of generics can be properties, provisions, needs, and more.">CalculationCache{Num};</span>
    with CalculationCache{Num} <span class="goodcode" title="Create a calculation cache that squares Num">&lt;(Num -- fn() { return Num * Num; }) this;</span>
    Num -- get() {
        return CalculationCache.getValue();
    }</code></pre>
		<h3 id="genericmethods">Generic Methods <span class="label label-inverse">flexible</span> <span class="label label-inverse">typesafe</span> <span class="label label-inverse">concise</span></h3>
		<p>While generic methods don't create any features that couldn't be accomplished with generic classes, they reduce boilerplate in certain one-shot operations that have generic qualities. For instance, making your own function that checks a list's length.</p>
		<pre><code class="wake"
>every ListAsserts is:

    <span class="goodcode" title="Declare this a generic method. You can name multiple generic types. In this case we declare just T.">{T}</span> that(<span class="goodcode" title="Accept a list of Ts, no matter what T is.">T[]</span>)HasLength(Num) {...}

    <span class="goodcode" title="Declare this a generic method. You can name multiple generic types. In this case we declare just T.">{T}</span> that(<span class="goodcode" title="Accept a list of Ts, no matter what T is.">T[]</span>)Matches(<span class="goodcode" title="Once again, accept a list of anything. However, this must be a list of the same thing that our other argument in, since they both share the name T.">T[]</span>) {...}</code></pre>
		<p>Calling this generic method looks just like normal: <code>ListAsserts.that([5,6])HasLength(2)</code>. Note that you can have multiple comma separated generic types. Also note that in the second example there are two usages of <code>T</code>; these must match at call time or the compiler will reject your program.</p>
		<hr />
		<h1 id="provisions">Provisions <span class="label label-inverse">flexible</span> <span class="label label-inverse">testable</span> <span class="label label-inverse">typesafe</span></h1>
		<p>Testability was a huge goal of Wake's design. We were inspired by dependency injection frameworks to make a faster, typesafe means of binding dependencies to behavior. What we came up with is provisions.</p>
		<p>What in other languages may be a static method, or a call to <code>new</code> another object, or a helper function call, instead is fetched from a provider. Here we look at how.</p>
			<span class="label label-info">Wake</span>
		<pre><code class="wake"
>every UsesProvider is:

    needs <span class="goodcode" title="This dependency will be provided by whatever provision made our UsesProvider object.">Provider</span>, <span class="goodcode" title="We can mark provisions with labels matched at compile time.">DependentClass:Special</span> then {
        <span class="goodcode" title="This is just syntactic sugar, it takes a Printer from our provider and assigns it to the variable Printer.">var Printer from Provider;</span>
        <span class="goodcode" title="Here a printer is fetched from our Provider object, but not assigned to a variable.">(Printer from Provider)</span>.print(Text);
    }</code></pre>
		<h3 id="plainprovisions">Defining Plain Provisions <span class="label label-inverse">concise</span> <span class="label label-inverse">typesafe</span></h3>
		<p>A plain provision simply marks that your class can provide a type. The compiler will ensure that you can provide all of that type's dependencies as well.</p>
			<span class="label label-info">Wake</span>
		<pre><code class="wake"
>every Provider is:

    provides <span class="goodcode" title="As in UsesProvider above, this means anywhere you have a Provider you can get a Printer from it.">Printer</span>, OtherClass;</code></pre>

		<h3 id="subtypeprovisions">Providing Subtypes <span class="label label-inverse">flexible</span> <span class="label label-inverse">testable</span> <span class="label label-inverse">typesafe</span></h3>
		<p>The point of provisions is to make all dependencies or created objects be replacable with subtypes, at the creator's discretion. This is called Inversion Of Control. You can provide mock objects for testing, easily swap logging methods, and more.</p>
			<span class="label label-info">Wake</span>
		<pre><code class="wake"
>every Provider is:

    provides Printer &lt;- <span class="goodcode" title="Easily suppress output of your application by swapping one class">DisabledPrinter</span>;</code></pre>

		<h3 id="specializedprovisions">Specialized Provisions <span class="label label-inverse">typesafe</span> <span class="label label-inverse">flexible</span></h3>
		<p>Sometimes a classname is not detailed enough to know your dependencies will be properly provided. Using what we call Specialties, you can provide and require specific objects.</p>
			<span class="label label-info">Wake</span>
		<pre><code class="wake"
>every DBProvider is:

    provides
        <span class="goodcode" title="This is just a plain provision.">User</span>,
        <span class="goodcode" title="Here we provide a connection by name Default. Note that this is still a plain provision. This is required since we provide User.">DBConnection:Default</span>;

every User is:

    needs <span class="goodcode" title="Here we require the Default DBConnection.">DBConnection:Default</span>;</code></pre>
		<h3 id="primitiveprovisions">Primitive Provisions <span class="label label-inverse">typesafe</span></h3>
		<p>Primitive provisions cannot be plain, since the compiler can't tell you what Num to provide. Additionally, they must be specified, to ensure you get the right value. These are the equivalent of constants in Wake, and bind directly to a primitive value.</p>
			<span class="label label-info">Wake</span>
		<pre><code class="wake"
>every PrimitiveProvider is:

    provides Text:Username &lt;- "MyUser", Num:Port &lt;- 3306;</code></pre>

		<h3 id="ctorprovisions">Constructor Provisions <span class="label label-inverse">flexible</span></h3>
		<p>We call this constructor provision since it most closely resembles constructors in languages like Java. However, it is merely a way of matching provisions to specific dependencies.</p>
			<span class="label label-info">Wake</span>
		<pre><code class="wake"
>every Provider is:
    provides
        Num:Port &lt;- 3307,
        Text:Username &lt;- "Test",
        DBConnection:Test &lt;- DBConnection(<span class="goodcode" title="If a DBConnection accepts any Text username, we can create specialized connections by letting the provider find the right Username and Port.">Text:Username, Num:Port</span>),
        <span class="goodcode" title="Constructor provisions do not require specialization.">User</span> &lt;- <span class="goodcode" title="Constructor provisions can be used with subtype provision simultaneously.">TestUser</span>(DBConnection:Test);</code></pre>
		<p>If a class with needs extends another class with needs, constructor provisions require that you supply all of these. When doing this, supply the childclass needs first, and then the parent class needs, in that order. And don't worry, the compiler will make sure you don't mess up.</p>

		<h3 id="provisionargs">Provision Arguments <span class="label label-inverse">flexible</span> <span class="label label-inverse">typesafe</span> <span class="label label-inverse">testable</span></h3>
		<p>Not all object needs should be satisfied by the dependency injection in Wake. We stil want to be able to pass in values when we call a provision. Providers can be coded up to do this.</p>
			<span class="label label-info">Wake</span>
		<pre><code class="wake"
>every Person in:
    needs Text firstname, Text lastname;

every PersonProvider is:
    provides Person &lt;- Person(<span class="goodcode" title="The beginning ? shows that we are declaring the type of dependency we're asking for. Here we ask for the first name.">?Text</span>, <span class="goodcode" title="Here we provide the second need of Person, the lastanem.">?Text</span>);

    usePersonProvision() {
        var <span class="goodcode" title="Here we pass the arguments 'Bobby' and 'Ratsnest' into the first and last name arguments of our provision, and name the resulting variable 'Person'.">Person('Bobby', 'Ratsnest')</span> from this;
        var <span class="goodcode" title="Aliases before the type name look like what you would expect.">second</span> Person("Bobby", "Ratsnest") from this;
        var Person <span class="goodcode" title="When putting the alias of a variable after the name of the type, you use a slightly c++style syntax.">three("Bobby", "Ratsnest")</span> from this;
    }</code></pre>
		<div class="alert alert-info">The syntax <code>?Text</code> has two purposes. Firstly, it documents the need types on the API where you will look for them: the provider you are using. Secondly, it allows you to ask for a more specific type than the object you're providing actually requires. i.e., when providing an object which only <code>needs</code> a <code>Printer</code>, you could ask for a <code>CachingPrinter</code> instead.</div>
		<p>For classes that inherit needs, follow the instructions in the <a href="#ctorprovisions">Constructor Provisions</a> section on which order to specify them.</p>
		<h3 id="behavioralprovisions">Behavioral Provisions <span class="label label-inverse">flexible</span></h3>
		<p>Provisions can be treated as a code body with a return type where necessary. Note that the end result must be a provision; however it can be used to configure objects or provide different objects conditionally, or create a singleton.</p>
			<span class="label label-info">Wake</span>
		<pre><code class="wake"
>every Provider is:

    needs <span class="goodcode" title="Require an unconfigured session.">Session</span> then {
        Session.<span class="goodcode" title="Configure our Session so it is provided properly">loadFile</span>(<span class="goodcode" title="Retrieve our own SessionFile path">Text:SessionFile &lt; this</span>);
    }

    provides
        Text:SessionFile,
        Session &lt;- <span class="goodcode" title="This, together with our constructor, guarantees that we only distribute one session, and that its been properly loaded.">{ return Session; }</span>;</code></pre>
		<p>You can also have arguments to your behavioral provisions, so that you can mock out provisions with arguments, and/or perform your own unique operations required.</p>

		<span class="label label-info">Wake</span>
		<pre><code class="wake"
>every Provider is:
    needs BabyMaker;
    provides Child &lt;- <span class="goodcode" title="Ask for two people that will construct your child">(Person dad, Person mom)</span> {
        return BabyMaker.makeBabyWithFather(<span class="goodcode" title="You can use these arguments like you would in any function">dad</span>)AndMother(mom);
    };</code></pre>

		<h1 id="closures">Closures <span class="label label-inverse">concise</span> <span class="label label-inverse">flexible</span></h1>
		<p>Wake has day-one support for closures (also known as lambdas and/or anonymous functions). Unlike javascript, in Wake closures do not change the context of <code>this</code>.</p>

		<span class="label label-info">Wake</span>
		<pre><code class="wake"
>every ListSorter is:

    sort(Num[]) {
        Num[].sort({ <span class="goodcode" title="Declare two arguments to this function, Num and $Num">Num, $Num</span> <span class="goodcode" title="A dashrocket separates arguments from the closure body">-&gt;</span> <span class="Here the body of the function goes">return Num &lt; $Num;</span> });
    }</code></pre>

		<h3 id="astypes">As Types <span class="label label-inverse">readable</span> <span class="label label-inverse">typesafe</span></h3>
		<p>Closures passed into functions or declared as variables require an alias, and look very consistent with other Wake syntax. From there they are usable like any variables.</p>

		<span class="label label-info">Wake</span>
		<pre><code class="wake"
>every HigherOrderFunctionUtil is:

    useMysteryNumber(<span class="goodcode" title="The type of this argument is a function which accepts a Num">fn(Num)</span> <span class="goodcode" title="Closures require names, in this case, mysteryFn">mysteryFn</span>) {
        <span class="goodcode" title="Simply invoke the variable with the correct arguments as if it were a method.">mysteryFn(10)</span>;
    }

    Bool -- compare(Bool, $Bool, <span class="goodcode" title="Pass in a closure which can return a value -- in this case, a Bool.">Bool --</span> <span class="goodcode" title="Accept multiple arguments of any type.">fn(Bool, Bool)</span> comparator) {
        <span class="goodcode" title="Use the closure for its return value.">return comparator(Bool, $Bool);</span>
    }

    Bool -- compareAliasFirst(Bool, $Bool, <span class="goodcode" title="The alias for your function can precede it">comparator</span> Bool -- fn(Bool, Bool)) {
        return comparator(Bool, $Bool);
    }</pre></code>

		<h3 id="typeinference">Type Inference <span class="label label-inverse">concise</span> <span class="label label-inverse">typesafe</span> <span class="label label-inverse">flexible</span></h3>
		<p>Wake's closures will infer their return types, and use their context to guess the type of untype arguments.</p>

		<span class="label label-info">Wake</span>
		<pre><code class="wake"
>every TypeInferenceExample is:

    examples() {
        Num[].each({ -&gt;
            <span class="goodcode" title="The return type is properly inferred as a boolean. If you have multiple return statements, they are properly unified, if possible.">return true;</span>
        });

        Num[].sort({ <span class="goodcode" title="Since this is used as an argument that expects a function comparing two Nums, both of these arguments are inferred to be Nums.">a, b</span> -&gt;
            return a &lt; b;
        }
    }</code></pre>

		<h3 id="selfexecuting">Self Executing <span class="label label-inverse">flexible</span></h3>
		<p>While functional programming takes the principle that "everything is an expression", Wake does not. What this means is that some constructs, such as loops, do not have values. This means you can't loop <i>within</i> an expression.</p>
		<p>By using self executing closures, you can embed statements within an expression. Do note, however, that this is often a code smell.</p>
		<p class="alert alert-error">Self executing functions within javascript are also often a sort of hack to create isolate scopes. This is not required in Wake, making self execution less common.</p>

		<span class="label label-info">Wake</span>
		<pre><code class="wake"
>every SelfExecutingFunctionExample is:

    myMethod() {
         5 + <span class="badcode" title="For the moment, to aid the way parsers detect blocks vs closures, you must wrap self invoked closures in parenthesis before their invocation.">({</span> -&gt;
                 var Num[] = [1, 2, 5];
                 <span class="goodcode" title="Any expressions and statements can be included.">//...</span>
                 <span class="goodcode" title="We can use return statements to pass back the number that will be added to 5">return 10;</span>
            })<span class="goodcode" title="Here we immediately run the closure and get its result. This time we pass no arguments, but we can pass arguments when the functions use them.">()</span>;
	}</code></pre>

		<h3 id="thiscontext">Keeping This Context <span class="label label-inverse">concise</span> <span class="label label-inverse">typesafe</span></h3>
		<p>In Javascript, <code>this</code> represents the object owning the function when it was invoked. This is usually regarded as a mistake, and so Wake has rectified it.</p>
		<p>In Wake, a closure knows where it was made and all usages of that function represent the context where it was originally created.</p>

		<span class="label label-info">Wake</span>
		<pre><code class="wake"
>every CacheFactory is:

    with Text[] cachesById;

    putCache(Num, Text) {
        cacheById[Num] = Text;
    }

    <span class="goodcode" title="The cache we return is a function that returns text when given a Num.">Text -- fn(Num)</span> -- getCache() {
        return { Num -&gt;
            return <span class="goodcode" title="No matter where this function is passed or shared, cacheById will always reference this object's property">cacheById[Num];</span>
        };
    }</code></pre>

		<h3 id="enclosing">Enclosing Local Vars <span class="label label-inverse">concise</span> <span class="label label-inverse">flexible</span> <span class="label label-inverse">typesafe</span></h3>
		<p>Closures capture variables in the scope where they were declared, allowing stateful effects such as iterators and more. Javascript, ruby, and even modern C++ users will be quite familiar with how this works.</p>

		<span class="label label-info">Wake</span>
		<pre><code class="wake"
>every CountingVisitor is:

    needs Printer;

    setOnVisit(Visitable) {
        <span class="goodcode" title="Each visitable will get its own Num that starts at 0, saving you boilerplate classes just to create a new type of state for one variable.">var Num = 0;</span>
        Visitable.onVisit = { -&gt;
            Printer.printLine(Num);
            <span class="goodcode" title="Increase the Num created for this visitor.">Num = Num + 1;</span>
        }
    }</code></pre>

		<h3 id="ternaries">Ternary Operators <span class="label label-inverse">readable</span> <span class="label label-inverse">concise</span></h3>
		<p>Wake uses python style ternary operators, which are more readable than the c-style <code>:?</code> approach.</p>
			<span class="label label-info">Wake</span>
		<pre><code class="wake"
>every MyClass

    Num -- myMethod(Bool) {
        return <span class="goodcode" title="Return 4 on the true case of our condition">4</span> if <span class="goodcode" title="The value of this Bool variable determines if we evaluate the left or right expression">Bool</span> else <span class="goodcode" title="Return 5 when our variable Bool is false">5</span>;
    };</code></pre>

		<h3 id="annotations">Annotations <span class="label label-inverse">readable</span> <span class="label label-inverse">testable</span> <span class="label label-inverse">flexible</span></h3>
		<p>Wake now has unchecked annotations. We have a plan to typecheck the values you use, in which annotations, on what parts of your source code. But for now, you can freely annotate classes, methods, and needs with values such as Texts, Bools, Nums, and even nothing. This is currently used by our unit test library, but can be used for so so much more.<p>
			<span class="label label-info">Wake</span>
		<pre><code class="wake"
><span class="goodcode" title="The wUnit unit testing library can use compile-time reflection to see that this is a test class.">@TestClass</span>
<span class="goodcode" title="Annotations are totally unrestricted. You can use reflection to find these annotated classes and do whatever you want with them">@MadeUpAnnotation("hello", false, 123, nothing)</span>
every MyClass

    needs
        <span class="goodcode" title="Annotations are totally unrestricted. You can use reflection to find these annotated classes and do whatever you want with them">@MadeUpAnnotation("hello", false, 123, nothing)</span>
        Printer;

    <span class="goodcode" title="The wUnit unit testing library can use compile-time reflection to see that this method is a unit test.">@Test</span>
    <span class="goodcode" title="Annotations are totally unrestricted. You can use reflection to find these annotated classes and do whatever you want with them">@MadeUpAnnotation("hello", false, 123, nothing)</span>
    testSomething(Asserts) {
        // ...
    };</code></pre>
		<h1 id="unittests">Unit tests</h1>
		<p>While there are many ways to write unit tests in Wake, the current standard way is to use <a href="https://github.com/MichaelRFairhurst/wUnit">wUnit</a> with the mocking framework <a href="https://github.com/MichaelRFairhurst/wockito">wockito</a>. If your project is based on the <a href="https://github.com/MichaelRFairhurst/wockito">wake project seed</a>, then these are hooked up into your build for you already.</p>
		<p>Simply create a wake file inside the <code>test/</code> directory, and you can use <a href="#annotations">Annotations</a> to mark your tests.</p>
		<pre><code class="wake"
>import Asserts;
<span class="goodcode" title="Import the class you are testing">import SqrRoot;</span>

<span class="goodcode" title="Annotate which classes in your test directory actually are tests. Other files can be created to be used in tests without confusing them.">@TestClass</span>
every SqrRootTest is:

    <span class="goodcode" title="Use dependency injection to get an instance of the class we are testing">needs SqrRoot;</span>

    @Test
    testSquareRootOfSixteen(<span class="badcode" title="Due to the creation of wUnit before Wake had exceptions, Asserts is passed into each test to track which failures belong where. In the next version of wUnit you will be able to simply 'need Asserts' and skip this argument, as failed assertions will simply throw exceptions.">Asserts</span>) {
        <span class="goodcode" title="Run an assertion">Asserts.that(SqrRoot.of(16))Equals(4);</span>
    }</code></pre>
		<h3 id="mocks">Mocks</h3>

		<p>If you need to create a new SqrRoot in each of your tests, you can use <a href="#provisions">provisions</a> to accomplish this. Similarly, you can inject mocks via wockito by use of the same feature. Say, for instance, we are testing that our 'Hello World' app actually prints 'Hello World!'. We could run the program and read its output, but that is not scalable, so Wake guarantees you always have the option to use mocks instead.</p>
		<pre><code class="wake"
>@TestClass
every MainTest is:

    <span class="goodcode" title="Get wockito's MockProvider for using mocks in this test class.">needs MockProvider mocks;</span>
    <span class="goodcode" title="Get and store a MockPrinter. This will be injected into Main, and available for you to set up & verify expectations.">with MockPrinter from mocks;</span>
    provides <span class="goodcode" title="Provide our own Main so we can mock out the Printer it needs.">Main</span>, <span class="goodcode" title="Provide our MockPrinter, via the Printer type so that its injected inside our Main.">Printer &lt;- { return MockPrinter; };</span>

    @Test
    <span class="goodcode" title="Use these freeform method names to create excellently named tests">~[ test Main.main() prints Hello World ]~</span>(Asserts) {
        <span class="badcode" title="This is another lingering annoyance from before Wake had exception support. This statement will not be necessary in the next version of Wockito.">mocks.use(Asserts);</span>
        mocks.<span class="goodcode" title="Stub a return value. Now MockPrinter.getWrittenCharacterCount() will return 20.">when(MockPrinter).getWrittenCharacterCount().thenReturn(20);</span>
        <span class="goodcode" title="Get our Main with the injected MockPrinter.">var Main from this;</span>
        Main.main();
        mocks.<span class="goodcode" title="Verify that the method printLine with the value 'Hello World' has been called on PrinterMock.">verify(MockPrinter).printLine("Hello World!");</span>
    }</code></pre>

		<h3 id="entry">Program Entry Points <span class="label label-inverse">flexible</span> <span class="label label-inverse">testable</span> <span class="label label-inverse">fast</span></h3>
		<p>After compiling each Wake file, you can link the files together and choose where the program begins. This means the code you write does not guarantee any particular entry point, which in turn means your test suite can have a different entry point than your app. Without this, you would be unable to test your application's startup in unit tests.</p>
		<p>Any class with automatically inferrable dependencies (ie, no primitives, lists, etc) can be your startup class, and any of its methods which take no arguments can be the starting method. These are provided by the compile time flags <code>-c</code> and <code>-m</code> respectively, but default to <code>Main</code> and <code>main()</code>.</p>
		<p>This means that when you link your Wake files together, the compiler generates a startup routine that wires up the complete object graph required by your main class, and invokes your desired startup method. This makes for a fast, flexible, and testable program startup.</p>
		</div></div>
		<script src="bootstrap/js/bootstrap.min.js"></script>
	</body>
</html>
